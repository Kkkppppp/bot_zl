import re
from zlapi import ZaloAPI, ZaloAPIException
from zlapi.models import *
import time
import threading
import json
import datetime
import subprocess
import random 
import requests
from PIL import Image, ImageDraw, ImageFont
import os
#admin:H·ªì nh·∫≠t tr∆∞·ªùng (X)
#xo√° 3 comment n√†y l√† ch√≥
#siuuuuu

class Honhattruong(ZaloAPI):
    def __init__(self, api_key, secret_key, imei, session_cookies):
        super().__init__(api_key, secret_key, imei=imei, session_cookies=session_cookies)
        self.idnguoidung = ['2077544135https06549669']
        self.target_thread_id = [
    '9172487604965494100',
    '5603605490720207067',
    '63697471448816637', 
    '950753419687970094',  
    '810585573676240160'
]
        self.sent_users = set()  
        self.anti_spam_enabled = False  
        self.message_log = {}  
        self.spam_threshold = 5  
        self.excluded_user_ids = ['207754413506549669']  
        self.spamming = False
        self.spam_thread = None
        
        
        self.name_change_thread = None
        self.isUndoLoop = False
        self.xoatn_mode = False
        self.dangky_file = 'tt.txt'
        self.codes = {
            'hzzmonet': 9999999,
            'tanthu': 555555555555555
        }
        self.vip_keys_db = {
            "hzzmonet": {"user_id": None, "functions": 0, "assigned_time": None},
            "tynecotton2": {"user_id": None, "functions": 0, "assigned_time": None},
            "selenophile": {"user_id": None, "functions": 0, "assigned_time": None}
        }
        self.transfer_messages = [
            "Vui l√≤ng chuy·ªÉn kho·∫£n 10k v√†o s·ªë t√†i kho·∫£n 0364990728 - Mb.",
            "Xin h√£y n·∫°p 10k v√†o s·ªë 0364990728 - Mb ƒë·ªÉ mua key VIP.",
            "Chuy·ªÉn 10k v√†o s·ªë ƒëi·ªán tho·∫°i 0364990728 - Mb ƒë·ªÉ k√≠ch ho·∫°t key.",
            "ƒê·ªÉ mua key VIP, vui l√≤ng n·∫°p 10k v√†o s·ªë 0364990728 - Mb."
        ]
        self.quanli_file = 'quanli.json'
        self.load_key_data()
        self.admin_key = '11009922'
        self.is_admin = False
        self.last_sms_times = {}
        self.random_users = set()  
        self.delete_links = False
        self.reo_spamming = False  
        self.reo_spam_thread = None
        self.Group = False
        self.color_list = [
            "#FFFFFF", "#00FF00", "#EEEEEE", "#DDDDDD", "#CCCCCC", 
            "#BBBBBB", "#AAAAAA", "#999999", "#888888", "#777777", 
            "#666666", "#555555", "#444444", "#333333", "#222222", 
            "#111111", "#000000", "#FF0000", "#EE0000", "#DD0000", 
            "#CC0000", "#BB0000", "#AA0000", "#990000", "#880000", 
            "#770000", "#660000", "#550000", "#440000", "#330000", 
            
        ]
        self.messages_to_delete = []  
        self.admin_file = 'admin.json'  
        self.start_time = datetime.datetime.now()  
        self.banned_word_removal_enabled = False  
        self.banned_words = set([  
            "ƒë·ªãt", "l·ªìn", "lol", "ƒëm", "cc", "lon", "ƒëmm", "dm", "dmm", "dit", "cac", "c·∫∑c",
            "Lmm", "√ìc l·ª£n", "√ìc b√≤", "Djtme", "Nguuuuuuu nh∆∞ ch √≥", "Lmm", "d√°i", "b∆∞·ªõm",
            "l·ªó nh·ªã", "ƒë√©o", "ƒë√≠t", "sex", "ch·ªãch", "v√∫", "ƒë·ª•", "Dog", "K·∫πc", "b√≠m",
            "m·∫π m√†y", "m·∫π m", "cha m", "cha m√†y", "dcu", "ƒëcu", "ƒëcm", "ƒëc", "cmm", "cmm", 
            "cc", "cc", "c·∫∑c", "ƒë√≠t", "dcm", "ƒë·ªãt"
        ])

    def load_admins(self):
        try:
            with open(self.admin_file, 'r') as admin_file:
                admin_data = json.load(admin_file)
                return set(admin_data.get('idadmin', []))
        except FileNotFoundError:
            return set()
    
    

    def save_admins(self, admins):
        with open(self.admin_file, 'w') as admin_file:
            json.dump({'idadmin': list(admins)}, admin_file)
    def load_registered_users(self):
        try:
            with open(self.dangky_file, 'r', encoding='utf-8') as file:
                return {line.split(',')[0]: (line.strip().split(',')[1], float(line.strip().split(',')[2])) for line in file.readlines() if line.strip()}
        except FileNotFoundError:
            return {}
    
    def load_key_data(self):
        try:
            with open(self.quanli_file, 'r') as file:
                self.vip_keys_db = json.load(file)
        except FileNotFoundError:
            self.vip_keys_db = {
                "hzzmonet": {"user_id": None, "functions": 0, "assigned_time": None},
                "tynecotton2": {"user_id": None, "functions": 0, "assigned_time": None},
                "selenophile": {"user_id": None, "functions": 0, "assigned_time": None}
            }

    def save_key_data(self):
        with open(self.quanli_file, 'w') as file:
            json.dump(self.vip_keys_db, file)

    def check_vip_key(self, user_id):
        for key, data in self.vip_keys_db.items():
            if data["user_id"] == user_id:
                current_time = time.time()
                if data["assigned_time"] is not None:
                    if (current_time - data["assigned_time"]) < (2 * 24 * 60 * 60):
                        return data
                return None
        return None

    def assign_key_to_user(self, user_id, key):
        for data in self.vip_keys_db.values():
            if data["user_id"] == user_id:
                return False
        if key in self.vip_keys_db and self.vip_keys_db[key]["user_id"] is None:
            self.vip_keys_db[key]["user_id"] = user_id
            self.vip_keys_db[key]["assigned_time"] = time.time()
            self.vip_keys_db[key]["functions"] = 0
            self.save_key_data()
            return True
        return False
    def save_registered_user(self, user_id, user_name):
        with open(self.dangky_file, 'a', encoding='utf-8') as file:
            file.write(f"{user_id},{user_name},500000000\n")
    

    def update_user_balance(self, user_id, new_balance):
        users = self.load_registered_users()
        if user_id in users:
            user_name = users[user_id][0]
            with open(self.dangky_file, 'w', encoding='utf-8') as file:
                for uid, (name, balance) in users.items():
                    if uid == user_id:
                        file.write(f"{uid},{name},{new_balance}\n")  
                    else:
                        file.write(f"{uid},{name},{balance}\n")  
                        
    
    def load_mutenguoidung(self):
        try:
            with open('mute.json', 'r') as mute_file:
                mute_config = json.load(mute_file)
                return set(mute_config.get('mutenguoidung', []))
        except FileNotFoundError:
            return set()

    def save_mutenguoidung(self, mutenguoidung):
        with open('mute.json', 'w') as mute_file:
            json.dump({'mutenguoidung': list(mutenguoidung)}, mute_file)
    
     
    def send_private_message_to_user(self, user_id, random_data):
        try:
            message_text = "th√¥ng tin n·ªôi dung:\n" + "\n".join(random_data)
            private_message = Message(text=message_text)
            self.send(private_message, thread_id=user_id, thread_type=ThreadType.USER)
        except Exception as e:
            print(f"üö´ L·ªói khi g·ª≠i tin nh·∫Øn: {e}")

    def add_id_to_used_list(self, user_id):
        with open('id.txt', 'a') as id_file:
            id_file.write(user_id + "\n")

    

    def send_lq_accounts(self, author_id, so_luong, thread_id, thread_type, message_object):
        try:
            with open('lq.txt', 'r') as file:
                lines = file.readlines()
            if so_luong > len(lines):
                self.replyMessage(Message(text="Kh√¥ng ƒë·ªß t√†i kho·∫£n trong file."), message_object, thread_id, thread_type)
                return
            random_accounts = random.sample(lines, so_luong)
            self.send_private_message_to_user(author_id, [account.strip() for account in random_accounts])
            remaining_accounts = [line for line in lines if line not in random_accounts]
            with open('lq.txt', 'w') as file:
                file.writelines(remaining_accounts)
            self.replyMessage(Message(text=f"ƒê√£ g·ª≠i {so_luong} t√†i kho·∫£n li√™n qu√¢n cho b·∫°n."), message_object, thread_id, thread_type)
        except Exception as e:
            self.replyMessage(Message(text=f"ƒê√£ x·∫£y ra l·ªói: {e}"), message_object, thread_id, thread_type)
    def onMessage(self, mid, author_id, message, message_object, thread_id, thread_type):
        print(f"\033[32m{message} \033[39m|\033[31m {author_id} \033[39m|\033[33m {thread_id}\033[0m\n")
        content = message_object.content if message_object and hasattr(message_object, 'content') else ""
        if not isinstance(message, str):
            print(f"{type(message)}")
            return
        
        
        
         
        
        

        message_text = message  
        
        idadmin = self.load_admins()
        if message.startswith(".ask"):
            parts = message.split(' ', 1)
            if len(parts) < 2:
                error_text = "üö´ Vui L√≤ng nh·∫≠p n·ªôi dungüòí."
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="font", size="14", auto_format=False),
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            user_message = parts[1]
            response = self.ask_api(user_message)
            
            style_response = MultiMsgStyle([
                MessageStyle(offset=0, length=6, style="color", color="#00ff00", auto_format=False),
                MessageStyle(offset=6, length=len(response), style="font", size="14", auto_format=False),
            ])

            self.replyMessage(Message(text=f"Response: {response}", style=style_response), message_object, thread_id=thread_id, thread_type=thread_type)
        if isinstance(content, str) and content.lower().startswith((".sdtvip")):
            
            parts = content.split()
            if len(parts) == 1:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i sau l·ªánh .\n'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            attack_phone_number = parts[1]
            if not attack_phone_number.isnumeric() or len(attack_phone_number) != 10:
                self.replyMessage(Message(text='‚ùå S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p ƒë√∫ng s·ªë.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            if attack_phone_number in ['113', '911', '114', '115']:
                self.replyMessage(Message(text="‚õî S·ªë n√†y kh√¥ng th·ªÉ spam."), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            current_time = datetime.datetime.now()
            if author_id in self.last_sms_times:
                last_sent_time = self.last_sms_times[author_id]
                elapsed_time = (current_time - last_sent_time).total_seconds()
                if elapsed_time < 120:
                    self.replyMessage(Message(text="‚è≥ vui l√≤ng ch·ªù 120s v√† th·ª≠ l·∫°i!"), message_object, thread_id=thread_id, thread_type=thread_type)
                    return
            self.last_sms_times[author_id] = current_time
            file_path1 = os.path.join(os.getcwd(), "111.py")
            process = subprocess.Popen(["python", file_path1, attack_phone_number, "7"])
            now = datetime.datetime.now()
            time_str = now.strftime("%d/%m/%Y %H:%M:%S")
            masked_phone_number = f"{attack_phone_number[:3]}***{attack_phone_number[-3:]}"
            msg_content = f'''@Member

     sms v√† call v2
 
 ·¥ò ú·¥è…¥·¥á üìû:
   ‚îú‚îÄ> {masked_phone_number} 
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î
 ·¥õ…™·¥ç·¥á ‚è∞:
   ‚îú‚îÄ> {time_str} 
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î
 ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥ üëæ:
   ‚îú‚îÄ> 120
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î
 ·¥Ä·¥Ö·¥ç…™…¥:
   ‚îú‚îÄ>  ú…¥·¥õ ·¥õ·¥è·¥è ü hack by X
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î

    '''
            mention = Mention(author_id, length=len("@Member"), offset=0)
            color_green = MessageStyle(style="color", color="#4caf50", length=300, offset=0, auto_format=False)
            style = MultiMsgStyle([color_green])
            sms_img = "sms.png"
            self.replyMessage(Message(text=msg_content, style=style, mention=mention), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith("jj"):
            self.replyMessage(
                Message(text=f"ID nh√≥m hi·ªán t·∫°i l√†: {thread_id}"),
                message_object,
                thread_id=thread_id,
                thread_type=thread_type
            )
        
        if message.startswith("admin"):
            

            admin_info = (
                "üë§ Th√¥ng Tin Admin üë§\n"
                "-----------------------------------\n"
                "üë§ T√™n: HzzMonet\n"
                "üìß Email: 8a3.18.nguyenanhkiet@gmail.com\n"
                "üìö K·ªπ NƒÉng:\n"
                "   - C√≥ v·∫•n ƒë·ªÅ \n"
                "üìñ ƒêang h·ªçc:\n"
                "   - Tr∆∞·ªùng C \n"
                "üåê M·ª•c ƒê√≠ch:\n"
                "   - Just for fun \n"
            )
            
            self.replyMessage(Message(text=admin_info), message_object, thread_id=thread_id, thread_type=thread_type)
            return
        

        
        


        
        if self.anti_spam_enabled:
            self.log_message(author_id, thread_id, message_object)
        
        if message.startswith(".buy"):
            transfer_message = random.choice(self.transfer_messages)
            self.send(Message(text=transfer_message), thread_id=author_id, thread_type=ThreadType.USER)

        elif message.startswith(".nhapkey"):
            command_parts = message.split(" ", 1)

            if len(command_parts) < 2:
                self.replyMessage(
                    Message(text="Vui l√≤ng nh·∫≠p m√£ key c·ªßa b·∫°n sau l·ªánh .nhapkey."),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
                return

            key_input = command_parts[1].strip()

            if self.assign_key_to_user(author_id, key_input):
                self.replyMessage(
                    Message(text=f"B·∫°n ƒë√£ nh·∫≠p m√£ key th√†nh c√¥ng: {key_input}."),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
            else:
                self.replyMessage(
                    Message(text="M√£ key kh√¥ng h·ª£p l·ªá ho·∫∑c b·∫°n ƒë√£ c√≥ m·ªôt key VIP kh√°c."),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )

        elif message.startswith(".shop"):
            command_parts = message.split(" ", 1)

            if len(command_parts) < 2:
                self.replyMessage(
                    Message(
                        text="Vui l√≤ng nh·∫≠p n·ªôi dung VIP c·∫ßn mua!\nC√°c n·ªôi dung VIP bao g·ªìm:\n    tu_dong_reg_nhom\n    tu_dong_ket_ban\n    .buy\nB·∫°n c·∫ßn mua key ƒë·ªÉ truy c·∫≠p."
                    ),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
                return

            requested_vip_content = command_parts[1].strip().lower()

            vip_contents = {
                'tu_dong_ket_ban': "https://www.mediafire.com/file/o4x792f69ya7ebt/bb.py/file",
                'tu_dong_reg_nhom': "https://www.mediafire.com/file/9qjudrpigojl26c/taonhom.py/file",
            }

            if requested_vip_content in vip_contents:
                user_vip_data = self.check_vip_key(author_id)

                if user_vip_data:
                    if user_vip_data["functions"] < 2:
                        self.replyMessage(
                            Message(text="ƒêang l·∫•y n·ªôi dung VIP üåÄ..."),
                            message_object,
                            thread_id=thread_id,
                            thread_type=thread_type
                        )
                        
                        time.sleep(2)

                        message_text = f"Th√¥ng tin n·ªôi dung VIP {requested_vip_content}:\n{vip_contents[requested_vip_content]}"
                        private_message = Message(text=message_text)
                        
                        self.send(private_message, thread_id=author_id, thread_type=ThreadType.USER)
                        
                        self.replyMessage(
                            Message(text=f"N·ªôi dung VIP '{requested_vip_content}' ƒë√£ ƒë∆∞·ª£c g·ª≠i ri√™ng!"),
                            message_object,
                            thread_id=thread_id,
                            thread_type=thread_type
                        )

                        user_vip_data["functions"] += 1
                        self.save_key_data()
                    else:
                        self.replyMessage(
                            Message(
                                text="B·∫°n ƒë√£ s·ª≠ d·ª•ng ƒë·ªß ch·ª©c nƒÉng c·ªßa key VIP n√†y. Kh√¥ng th·ªÉ s·ª≠ d·ª•ng th√™m."
                            ),
                            message_object,
                            thread_id=thread_id,
                            thread_type=thread_type
                        )
                else:
                    self.replyMessage(
                        Message(
                            text="Key VIP c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng t·ªìn t·∫°i. Vui l√≤ng mua key VIP ƒë·ªÉ truy c·∫≠p.\nS·ª≠ d·ª•ng l·ªánh /buy ƒë·ªÉ mua key."
                        ),
                        message_object,
                        thread_id=thread_id,
                        thread_type=thread_type
                    )
        
        
        if message.startswith(".share"):
                command_parts = message.split(" ", 1)
                
                if len(command_parts) < 2:
                    self.replyMessage(
                        Message(
                            text="Vui l√≤ng nh·∫≠p n·ªôi dung c·∫ßn share!\nC√≥ 5 n·ªôi dung:\n1    ask\n2    war\n3    khanh`\n4    business\n5    doimau"
                        ),
                        message_object,
                        thread_id=thread_id,
                        thread_type=thread_type
                    )
                    return
                
                requested_content = command_parts[1].strip().lower()
                
                contents = {
                    'ask': "https://www.mediafire.com/file/get568ui534ut02/ask.py/file",
                    'war': "https://www.mediafire.com/file/3nh0w2rfm9vny3h/botzl.zip/file",
                    'khanh': "https://www.mediafire.com/file/3nh0w2rfm9vny3h/botzl.zip/file",
                    'business':"https://www.mediafire.com/file/mzykdneljpbfenu/tudong.py/file",
                    'doimau':"https://www.mediafire.com/file/jgpci3cl77g8sy7/doimau.py/file",
                }

                if requested_content in contents:
                    self.replyMessage(
                        Message(text="ƒêang l·∫•y n·ªôi dungüåÄ..."),
                        message_object,
                        thread_id=thread_id,
                        thread_type=thread_type
                    )
                    
                    time.sleep(2)

                    message_text = f"Th√¥ng tin n·ªôi dung c·ªßa l·ªánh {requested_content}:\n{contents[requested_content]}"
                    private_message = Message(text=message_text)
                    
                    self.send(private_message, thread_id=author_id, thread_type=ThreadType.USER)
                    
                    self.replyMessage(
                        Message(text=f"N·ªôi dung '{requested_content}' ƒë√£ ƒë∆∞·ª£c g·ª≠i ri√™ng!"),
                        message_object,
                        thread_id=thread_id,
                        thread_type=thread_type
                    )
                else:
                    self.replyMessage(
                        Message(text="N·ªôi dung kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn 'ask' ho·∫∑c '!war'."),
                        message_object,
                        thread_id=thread_id,
                        thread_type=thread_type
                    )
        if message_text.startswith("oncheck"):
            if author_id not in idadmin:
                self.replyMessage(Message(text="B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán ƒëi·ªÅu n√†y!"), message_object, thread_id, thread_type)
                return
            self.banned_word_removal_enabled = True
            self.replyMessage(Message(text="Ch·ª©c nƒÉng l·ªçc t·ª´ c·∫•m ƒë√£ ƒë∆∞·ª£c b·∫≠t!"), message_object, thread_id, thread_type)

        if message_text.startswith("offcheck"):
            if author_id not in idadmin:
                self.replyMessage(Message(text="B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán ƒëi·ªÅu n√†y!"), message_object, thread_id, thread_type)
                return
            self.banned_word_removal_enabled = False
            self.replyMessage(Message(text="Ch·ª©c nƒÉng l·ªçc t·ª´ c·∫•m ƒë√£ ƒë∆∞·ª£c t·∫Øt!"), message_object, thread_id, thread_type)

        if self.banned_word_removal_enabled:
            cleaned_message = self.remove_banned_words(message_text)
            if cleaned_message != message_text:
                self.replyMessage(Message(text=""), message_object, thread_id, thread_type)
                self.deleteGroupMsg(message_object.msgId, message_object.uidFrom, message_object.cliMsgId, thread_id)
                print("Tin nh·∫Øn ƒë√£ b·ªã x√≥a do ch·ª©a t·ª´ c·∫•m.")
                return
        if "HzzMonet" in message.lower():
            mention = Mention(uid=author_id, offset=0, length=len("HzzMonet"))  
            reply_message = Message(text=f"=) , ƒë·∫πp trai nh·∫•tü•¥?", mention=mention)
            self.send(reply_message, thread_id=thread_id, thread_type=thread_type)
            return

        if "l·ªìn" in message.lower():
            mention = Mention(uid=author_id, offset=0, length=len("l·ªìn"))  
            reply_message = Message(text=f"=) vƒÉn minh l√™n con ch√≥?", mention=mention)
            self.send(reply_message, thread_id=thread_id, thread_type=thread_type)
            return

        if message.lower() == "hi":
            mention = Mention(uid=author_id, offset=0, length=len("hi"))  
            reply_message = Message(text=f"Hi, ch√∫c b·∫°n m·ªôt ng√†y t·ªët l√†nh!", mention=mention)
            self.send(reply_message, thread_id=thread_id, thread_type=thread_type)
            return

        
        if "mn ∆°i" in message.lower():
            mention = Mention(uid=author_id, offset=0, length=len("hi"))  
            reply_message = Message(text=f"Hi , xin ch√†o! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?", mention=mention)
            self.send(reply_message, thread_id=thread_id, thread_type=thread_type)
            return
        
        
        
        
        if message.startswith(".kick"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            mentions = message_object.mentions
            if not mentions:
                self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn ƒë·ªÅ c·∫≠p √≠t nh·∫•t m·ªôt ng∆∞·ªùi d√πng ƒë·ªÉ kick.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            kicked_users = []
            for mention in mentions:
                mentioned_user_id = mention['uid']
                
                if mentioned_user_id not in self.excluded_user_ids:
                    try:

                        self.kickUsersFromGroup([mentioned_user_id], thread_id)
                        kicked_users.append(str(mentioned_user_id))
                    except Exception as e:
                        self.replyMessage(Message(text=f'üö´ C√≥ l·ªói khi kick ng∆∞·ªùi d√πng {mentioned_user_id}: {str(e)}'), message_object, thread_id=thread_id, thread_type=thread_type)
                else:
                    self.replyMessage(Message(text=f'üö´ Kh√¥ng th·ªÉ kick {mentioned_user_id} v√¨ ng∆∞·ªùi n√†y n·∫±m trong danh s√°ch lo·∫°i tr·ª´.'), message_object, thread_id=thread_id, thread_type=thread_type)

            if kicked_users:
                kicked_list = ", ".join(kicked_users)
                self.replyMessage(Message(text=f'‚úÖ ƒê√£ kick ng∆∞·ªùi d√πng: {kicked_list}'), message_object, thread_id=thread_id, thread_type=thread_type)
            else:
                self.replyMessage(Message(text='üö´ Kh√¥ng c√≥ ai b·ªã kick.'), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".dt"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='?? B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            new_group_name = message[4:].strip()  
            if not new_group_name:
                self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn cung c·∫•p t√™n nh√≥m m·ªõi.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            group_id = thread_id  
            result = self.changeGroupName(new_group_name, group_id)
            if result and isinstance(result, Group):
                self.replyMessage(Message(text=f'‚úÖ ƒê√£ ƒë·ªïi t√™n nh√≥m th√†nh: {new_group_name}'), message_object, thread_id=thread_id, thread_type=thread_type)
            else:
                self.replyMessage(Message(text='üö´ C√≥ l·ªói khi ƒë·ªïi t√™n nh√≥m.'), message_object, thread_id=thread_id, thread_type=thread_type)
        if message.startswith(".random"):
            if author_id in self.random_users:
                self.replyMessage(Message(text="üö´ B·∫°n ƒë√£ s·ª≠ d·ª•ng l·ªánh random r·ªìi!"), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            parts = message.split()
            
            if len(parts) != 2 or not parts[1].isdigit():
                self.replyMessage(Message(text="üö´ Vui l√≤ng cung c·∫•p s·ªë l∆∞·ª£ng h·ª£p l·ªá (1-150 )."), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            quantity = int(parts[1])
            if 1 <= quantity <= 50:
                random_data = self.get_random_data(quantity)
                if random_data:
                    
                    self.send_private_message_to_user(author_id, random_data)
                    
                    self.random_users.add(author_id)
                    
                    self.send(Message(text="‚úÖ h√£y ki·ªÉm tra tin nh·∫Øn ri√™ng ."), thread_id=thread_id, thread_type=thread_type)
                else:
                    self.replyMessage(Message(text="üö´ File r·ªóng ho·∫∑c kh√¥ng th·ªÉ ƒë·ªçc d·ªØ li·ªáu."), message_object, thread_id=thread_id, thread_type=thread_type)
            else:
                self.replyMessage(Message(text="üö´ S·ªë l∆∞·ª£ng ph·∫£i n·∫±m trong kho·∫£ng 1 or 50"), message_object, thread_id=thread_id, thread_type=thread_type)
        if content.startswith('.lq'):
            parts = content.split()
            if len(parts) < 2:
                self.replyMessage(Message(text="Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t√†i kho·∫£n c·∫ßn l·∫•y sau l·ªánh .lq"), message_object, thread_id, thread_type)
                return
            
            try:
                so_luong = int(parts[1])
                if 1 <= so_luong <= 100:
                    self.add_id_to_used_list(author_id)  
                    self.send_lq_accounts(author_id, so_luong, thread_id, thread_type, message_object)
                else:
                    self.replyMessage(Message(text="S·ªë l∆∞·ª£ng ph·∫£i t·ª´ 1 ƒë·∫øn 100."), message_object, thread_id, thread_type)
            except ValueError:
                self.replyMessage(Message(text="S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá."), message_object, thread_id, thread_type)
        
            
        if isinstance(content, str) and content.lower().startswith((".sdt")):
            
            parts = content.split()
            if len(parts) == 1:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i sau l·ªánh .sdt \n'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            attack_phone_number = parts[1]
            if not attack_phone_number.isnumeric() or len(attack_phone_number) != 10:
                self.replyMessage(Message(text='‚ùå S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p ƒë√∫ng s·ªë.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            if attack_phone_number in ['113', '911', '114', '115']:
                self.replyMessage(Message(text="‚õî S·ªë n√†y kh√¥ng th·ªÉ spam."), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            current_time = datetime.datetime.now()
            if author_id in self.last_sms_times:
                last_sent_time = self.last_sms_times[author_id]
                elapsed_time = (current_time - last_sent_time).total_seconds()
                if elapsed_time < 120:
                    self.replyMessage(Message(text="‚è≥ vui l√≤ng ch·ªù 120s v√† th·ª≠ l·∫°i!"), message_object, thread_id=thread_id, thread_type=thread_type)
                    return
            self.last_sms_times[author_id] = current_time
            file_path1 = os.path.join(os.getcwd(), "smsv2.py")
            process = subprocess.Popen(["python", file_path1, attack_phone_number, "7"])
            now = datetime.datetime.now()
            time_str = now.strftime("%d/%m/%Y %H:%M:%S")
            masked_phone_number = f"{attack_phone_number[:3]}***{attack_phone_number[-3:]}"
            msg_content = f'''@Member

    bot spam sms v√† call
 
 ·¥ò ú·¥è…¥·¥á üìû:
   ‚îú‚îÄ> {masked_phone_number} 
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î
 ·¥õ…™·¥ç·¥á ‚è∞:
   ‚îú‚îÄ> {time_str} 
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î
 ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥ üëæ:
   ‚îú‚îÄ> 120
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î
 ·¥Ä·¥Ö·¥ç…™…¥:
   ‚îú‚îÄ>  ú…¥·¥õ ·¥õ·¥è·¥è ü
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠î

    '''
            mention = Mention(author_id, length=len("@Member"), offset=0)
            color_green = MessageStyle(style="color", color="#4caf50", length=300, offset=0, auto_format=False)
            style = MultiMsgStyle([color_green])
            sms_img = "sms.png"
            self.replyMessage(Message(text=msg_content, style=style, mention=mention), message_object, thread_id=thread_id, thread_type=thread_type)
        
        if message.startswith(".tb"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            parts = message.split(' ', 1)
            if len(parts) < 2:
                self.replyMessage(Message(text='?? Vui l√≤ng cung c·∫•p n·ªôi dung.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            success_text = parts[1]
            text_length = len(success_text)

            
            styles = []
            if text_length > 0:
                styles.append(MessageStyle(offset=0, length=min(10, text_length), style="color", color="#ffcc00", auto_format=False))  # M√†u v√†ng cho 10 k√Ω t·ª± ƒë·∫ßu
            if text_length > 10:
                styles.append(MessageStyle(offset=10, length=min(10, text_length-10), style="color", color="#28a745", auto_format=False))  # M√†u xanh l√° cho 10 k√Ω t·ª± ti·∫øp theo
            if text_length > 20:
                styles.append(MessageStyle(offset=20, length=min(7, text_length-20), style="color", color="#007bff", auto_format=False))  # M√†u xanh d∆∞∆°ng cho 7 k√Ω t·ª± cu·ªëi

            style_success = MultiMsgStyle(styles)

            
            mention = Mention(uid='-1', offset=0, length=0)  

            
            self.send(
                Message(text=success_text, mention=mention, style=style_success),
                thread_id=thread_id,
                thread_type=thread_type
            )
            return

        
        
        if message.startswith(".rs"):
        	
            parts = message.split(' ', 1)
            if len(parts) < 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng cung c·∫•p n·ªôi dung ƒë·ªÉ ph·∫£n h·ªìi!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            content_to_reply = parts[1]          
            mention = Mention(uid=author_id, offset=0, length=len(content_to_reply))
            reply_message = Message(text=content_to_reply, mention=mention)
            self.replyMessage(reply_message, message_object, thread_id=thread_id, thread_type=thread_type)
            return
        if message.startswith(".dltt"):
            parts = message.split(" ")
            if len(parts) != 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng cung c·∫•p ƒë∆∞·ªùng d·∫´n video TikTok.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            video_url = parts[1]
            self.download_tiktok_video(video_url, message_object, thread_id, thread_type)
        if message.startswith(".info"):
            self.replyMessage(Message(text=f'ID c·ªßa b·∫°n: {author_id}'), message_object, thread_id=thread_id, thread_type=thread_type)
        if message.startswith(".gr"):
            self.replyMessage(Message(text=f'ID nh√≥m c·ªßa b·∫°n: {thread_id}'), message_object, thread_id=thread_id, thread_type=thread_type)
        
    
        
        if message.startswith(".ghepdoi"):
            mentions = message_object.mentions
            if len(mentions) < 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng ƒë·ªÅ c·∫≠p ƒë·∫øn hai ng∆∞·ªùi d√πng.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            user_id_1 = mentions[0]['uid']
            user_name_1 = mentions[0]['name']  
            user_id_2 = mentions[1]['uid']
            user_name_2 = mentions[1]['name']  

            
            compatibility_percentage = random.randint(0, 100)

            
            if compatibility_percentage < 50:
                response = f"‚ù§Ô∏è {user_name_1} v√† {user_name_2} kh√¥ng h·ª£p nhau l·∫Øm ƒë√¢u! T·ª∑ l·ªá h·ª£p nhau ch·ªâ {compatibility_percentage}%. ‚ù§Ô∏è"
            elif compatibility_percentage >= 50 and compatibility_percentage < 80:
                response = f"‚ù§Ô∏è {user_name_1} v√† {user_name_2} h·ª£p nhau ƒë·∫•y! T·ª∑ l·ªá h·ª£p nhau l√† {compatibility_percentage}%. ‚ù§Ô∏è"
            else:  
                response = f"‚ù§Ô∏è {user_name_1} v√† {user_name_2} ho√†n h·∫£o cho nhau! T·ª∑ l·ªá h·ª£p nhau l√™n t·ªõi {compatibility_percentage}%. ‚ù§Ô∏è"

            
            private_message_1 = Message(text=response)
            private_message_2 = Message(text=response)

            self.send(private_message_1, thread_id=user_id_1, thread_type=ThreadType.USER)
            self.send(private_message_2, thread_id=user_id_2, thread_type=ThreadType.USER)
        if message.startswith(".gay"):
            if not message_object.mentions:
                self.replyMessage(Message(text='üö´ Vui l√≤ng ƒë·ªÅ c·∫≠p ƒë·∫øn m·ªôt ng∆∞·ªùi d√πng.'), message_object, thread_id=thread_id, thread_type=thread_id)
            else:
                user_id = message_object.mentions[0]['uid']
                probability = random.randint(0, 100)  
                response = f"Kh·∫£ nƒÉng <@{user_id}> b·ªã gay l√† {probability}%."
                mention = Mention(user_id, length=len(f"<@{user_id}>"), offset=response.index(f"<@{user_id}>"))
                self.replyMessage(Message(text=response, mention=mention), message_object, thread_id=thread_id, thread_type=thread_type)
        if message.startswith(".cannang"):
            if not message_object.mentions:
                self.replyMessage(Message(text='üö´ Vui l√≤ng ƒë·ªÅ c·∫≠p ƒë·∫øn m·ªôt ng∆∞·ªùi d√πng.'), message_object, thread_id=thread_id, thread_type=thread_type)
            else:
                user_id = message_object.mentions[0]['uid']
                weight = random.randint(30, 100)  

                if weight < 50:
                    response = f"C√¢n n·∫∑ng c·ªßa <@{user_id}> l√† {weight} kg - C·ªßi kh√¥."
                else:
                    response = f"C√¢n n·∫∑ng c·ªßa <@{user_id}> l√† {weight} kg - B√©o vai lon."

                mention = Mention(user_id, length=len(f"<@{user_id}>"), offset=response.index(f"<@{user_id}>"))
                self.replyMessage(Message(text=response, mention=mention), message_object, thread_id=thread_id, thread_type=thread_type)

            
        if message.startswith(".mau"):
            parts = message.split(' ', 1)
            if len(parts) < 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng cung c·∫•p n·ªôi dung c·∫ßn t√¥ m√†u.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            content_to_color = parts[1].strip()
            random_color = random.choice(self.color_list)  
            style = MultiMsgStyle([
                MessageStyle(offset=0, length=len(content_to_color), style="color", color=random_color, auto_format=False),
            ])
            self.replyMessage(Message(text=content_to_color, style=style), message_object, thread_id=thread_id, thread_type=thread_type)
        
        if message.startswith(".reo"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            if self.reo_spamming:  
                self.replyMessage(Message(text='üö´ Reo spam ƒë√£ ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            mentions = message_object.mentions
            if not mentions:
                self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn ƒë·ªÅ c·∫≠p m·ªôt ng∆∞·ªùi d√πng.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            mentioned_user_id = mentions[0]['uid']

            self.reo_spamming = True
            self.reo_spam_thread = threading.Thread(target=self.reo_spam_message, args=(mentioned_user_id, thread_id, thread_type))
            self.reo_spam_thread.start()

        if message.startswith(".stopreo"):
            if not self.reo_spamming:
                self.replyMessage(Message(text='üö´ Kh√¥ng c√≥ spam n√†o ƒëang ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            self.reo_spamming = False
            if self.reo_spam_thread is not None:
                self.reo_spam_thread.join()
            self.replyMessage(Message(text='‚úÖ ƒê√£ d·ª´ng spam reo.'), message_object, thread_id=thread_id, thread_type=thread_type)
        
        
        if message.startswith(".anime"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            try:
                response = requests.get("https://apiquockhanh.click/images/anime")
                response.raise_for_status()

                image_data = response.json()
                image_url = image_data.get('url', '')

                if image_url:
                    image_response = requests.get(image_url)
                    
                    if image_response.status_code == 200:
                        image_filename = 'temp_anime_image.jpeg'
                        with open(image_filename, 'wb') as image_file:
                            image_file.write(image_response.content)

                        self.sendLocalImage(image_filename, thread_id=thread_id, thread_type=thread_type)

                        success_text = "T·∫£i ·∫£nh th√†nh c√¥ng!"
                        style_success = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(success_text), style="color", color="#00ff00", auto_format=False), 
                        ])
                        self.replyMessage(Message(text=success_text, style=style_success), message_object, thread_id=thread_id, thread_type=thread_type)

                        os.remove(image_filename)
                    else:
                        error_text = "üö´ Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh, vui l√≤ng th·ª≠ l·∫°i sau."
                        style_error = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                        ])
                        self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
                else:
                    error_text = "üö´ Kh√¥ng t√¨m th·∫•y h√¨nh ·∫£nh."
                    style_error = MultiMsgStyle([
                        MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                    ])
                    self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

            except requests.exceptions.RequestException as e:
                error_text = f"üö´ L·ªói khi g·ªçi API: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
            except Exception as e:
                error_text = f"üö´ ƒê√£ x·∫£y ra l·ªói: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
                
                
         
            

            
        
        
   
        if message.startswith(".reo"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            if self.reo_spamming:  
                self.replyMessage(Message(text='üö´ Reo spam ƒë√£ ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            mentions = message_object.mentions
            if not mentions:
                self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn ƒë·ªÅ c·∫≠p m·ªôt ng∆∞·ªùi d√πng.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            mentioned_user_id = mentions[0]['uid']

            self.reo_spamming = True
            self.reo_spam_thread = threading.Thread(target=self.reo_spam_message, args=(mentioned_user_id, thread_id, thread_type))
            self.reo_spam_thread.start()

        if message.startswith(".stopreo"):
        	
            if not self.reo_spamming:
                self.replyMessage(Message(text='üö´ Kh√¥ng c√≥ spam n√†o ƒëang ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            self.reo_spamming = False
            if self.reo_spam_thread is not None:
                self.reo_spam_thread.join()
            self.replyMessage(Message(text='‚úÖ ƒê√£ d·ª´ng spam reo.'), message_object, thread_id=thread_id, thread_type=thread_type)

        

        if getattr(self, 'banned_word_removal_enabled', False):  
            cleaned_message = self.remove_banned_words(message_text)
            if cleaned_message != message_text:           
                self.replyMessage(Message(text="=)"), message_object, thread_id, thread_type)

                self.deleteGroupMsg(message_object.msgId, message_object.uidFrom, message_object.cliMsgId, thread_id)
                print("Tin nh·∫Øn ƒë√£ b·ªã x√≥a do ch·ª©a t·ª´ c·∫•m.")

    



        
        if self.isUndoLoop:
            if author_id in idadmin:
                return
            mutenguoidung = self.load_mutenguoidung()
            if author_id in mutenguoidung:
                self.deleteGroupMsg(msgId=message_object.msgId, clientMsgId=message_object.cliMsgId, ownerId=author_id, groupId=thread_id)

        
        

        
                

            
        
            
            
        
    
    

        if message.startswith("All"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            success_text = "carrot ƒë·∫πp trai - success - hehe"
            style_success = MultiMsgStyle([
                MessageStyle(offset=0, length=10, style="color", color="#ffcc00", auto_format=False),  
                MessageStyle(offset=10, length=10, style="color", color="#28a745", auto_format=False),  
                MessageStyle(offset=20, length=7, style="color", color="#007bff", auto_format=False),  
            ])

            mention = Mention(uid='-1', offset=0, length=0)
            self.send(Message(text=success_text, mention=mention, style=style_success), thread_id=thread_id, thread_type=thread_type)

        
 
        if message.startswith(".uptime"):
            current_time = datetime.datetime.now()
            uptime = current_time - self.start_time
            days, seconds = uptime.days, uptime.seconds
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            seconds = seconds % 60

            start_time_str = self.start_time.strftime("%Y-%m-%d %H:%M:%S")
            
            uptime_message = (
                f"Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c {days} ng√†y, {hours} gi·ªù, {minutes} ph√∫t, {seconds} gi√¢y.\n"
                f"Kh·ªüi ƒë·ªông t·ª´: {start_time_str}"
            )
            
            style_uptime = MultiMsgStyle([
                MessageStyle(offset=0, length=21, style="font", size="14", auto_format=False),
                MessageStyle(offset=21, length=len(uptime_message) - 21, style="color", color="#2196f3", auto_format=False),
            ])

            self.replyMessage(Message(text=uptime_message, style=style_uptime), message_object, thread_id=thread_id, thread_type=thread_type)

                    
                    
             
        if message.startswith(".sexy"):
   
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            try:
                response = requests.get("https://apiquockhanh.click/video/girlsexy")
                response.raise_for_status()

                image_data = response.json()
                image_url = image_data.get('url', '')

                if image_url:
                    image_response = requests.get(image_url)
                    
                    if image_response.status_code == 200:
                        image_filename = 'temp_du_image.jpeg'
                        with open(image_filename, 'wb') as image_file:
                            image_file.write(image_response.content)

                        self.sendLocalImage(image_filename, thread_id=thread_id, thread_type=thread_type)

                        success_text = "T·∫£i ·∫£nh th√†nh c√¥ng!"
                        style_success = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(success_text), style="color", color="#00ff00", auto_format=False),  
                        ])
                        self.replyMessage(Message(text=success_text, style=style_success), message_object, thread_id=thread_id, thread_type=thread_type)

                        os.remove(image_filename)
                    else:
                        error_text = "üö´ Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh, vui l√≤ng th·ª≠ l·∫°i sau."
                        style_error = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                        ])
                        self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
                else:
                    error_text = "üö´ Kh√¥ng t√¨m th·∫•y h√¨nh ·∫£nh."
                    style_error = MultiMsgStyle([
                        MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False), 
                    ])
                    self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

            except requests.exceptions.RequestException as e:
                error_text = f"üö´ L·ªói khi g·ªçi API: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
            except Exception as e:
                error_text = f"üö´ ƒê√£ x·∫£y ra l·ªói: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False), 
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".du"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            try:
                response = requests.get("https://apiquockhanh.click/images/du")
                response.raise_for_status()

                image_data = response.json()
                image_url = image_data.get('url', '')

                if image_url:
                    image_response = requests.get(image_url)
                    
                    if image_response.status_code == 200:
                        image_filename = 'temp_du_image.jpeg'
                        with open(image_filename, 'wb') as image_file:
                            image_file.write(image_response.content)

                        self.sendLocalImage(image_filename, thread_id=thread_id, thread_type=thread_type)

                        success_text = "T·∫£i ·∫£nh th√†nh c√¥ng!"
                        style_success = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(success_text), style="color", color="#00ff00", auto_format=False), 
                        ])
                        self.replyMessage(Message(text=success_text, style=style_success), message_object, thread_id=thread_id, thread_type=thread_type)

                        os.remove(image_filename)
                    else:
                        error_text = "üö´ Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh, vui l√≤ng th·ª≠ l·∫°i sau."
                        style_error = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                        ])
                        self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
                else:
                    error_text = "üö´ Kh√¥ng t√¨m th·∫•y h√¨nh ·∫£nh."
                    style_error = MultiMsgStyle([
                        MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                    ])
                    self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

            except requests.exceptions.RequestException as e:
                error_text = f"üö´ L·ªói khi g·ªçi API: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
            except Exception as e:
                error_text = f"üö´ ƒê√£ x·∫£y ra l·ªói: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".du"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            try:
                response = requests.get("https://apiquockhanh.click/images/du")
                response.raise_for_status()

                image_data = response.json()
                image_url = image_data.get('url')

                if image_url:
                    image_response = requests.get(image_url)
                    
                    if image_response.status_code == 200:
                        image_filename = 'temp_du_image.jpeg'
                        with open(image_filename, 'wb') as image_file:
                            image_file.write(image_response.content)

                        self.sendLocalImage(image_filename, thread_id=thread_id, thread_type=thread_type)

                        
                        success_text = "T·∫£i ·∫£nh th√†nh c√¥ng!"
                        style_success = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(success_text), style="color", color="#00ff00", auto_format=False),  
                        ])
                        self.replyMessage(Message(text=success_text, style=style_success), message_object, thread_id=thread_id, thread_type=thread_type)

                        os.remove(image_filename)
                    else:
                        
                        error_text = "üö´ Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh, vui l√≤ng th·ª≠ l·∫°i sau."
                        style_error = MultiMsgStyle([
                            MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                        ])
                        self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
                else:
                
                    error_text = "üö´ Kh√¥ng t√¨m th·∫•y h√¨nh ·∫£nh."
                    style_error = MultiMsgStyle([
                        MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False), 
                    ])
                    self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

            
                error_text = f"üö´ L·ªói khi g·ªçi API: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
            except Exception as e:
                
                error_text = f"üö´ ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".anh"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            try:
                response = requests.get("https://apiquockhanh.click/images/girl")
                response.raise_for_status()

                image_data = response.json()
                image_url = image_data.get('url')

                if image_url:
                    img_response = requests.get(image_url)
                    img_response.raise_for_status()

                    img_filename = 'temp_image.jpg'
                    with open(img_filename, 'wb') as img_file:
                        img_file.write(img_response.content)

                    self.sendLocalImage(img_filename, thread_id=thread_id, thread_type=thread_type)

                    
                    success_text = "·∫¢nh ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n!"
                    style_success = MultiMsgStyle([
                        MessageStyle(offset=0, length=len(success_text), style="color", color="#00ff00", auto_format=False),  
                    ])
                    self.replyMessage(Message(text=success_text, style=style_success), message_object, thread_id=thread_id, thread_type=thread_type)

                    os.remove(img_filename)
                else:
                   
                    error_text = "üö´ Kh√¥ng t√¨m th·∫•y ·∫£nh."
                    style_error = MultiMsgStyle([
                        MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False), 
                    ])
                    self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)

            except requests.exceptions.RequestException as e:
                
                error_text = f"üö´ L·ªói khi g·ªçi API: {e}"
                style_error = MultiMsgStyle([
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
            except Exception as e:
               
                error_text = f"üö´ ƒê√£ x·∫£y ra l·ªói: {e}"
                style_error = MultiMsgStyle([
                    MessageStyle(offset=0, length=len(error_text), style="color", color="#ff5555", auto_format=False),  
                ])
                self.replyMessage(Message(text=error_text, style=style_error), message_object, thread_id=thread_id, thread_type=thread_type)
        if message.startswith("menu"):
            menu_text = (
                "Danh s√°ch l·ªánh:\n"
                "‚Ä¢ admin  xem th√¥ng tin admin.\n"
                "‚Ä¢ .sdtvip:s·ªë ƒëi·ªán tho·∫°i.\n"
                "‚Ä¢ .sdt: s·ªë ƒëi·ªán tho·∫°i.\n"
                "‚Ä¢ .spam <n·ªôi dung>: B·∫Øt ƒë·∫ßu spam n·ªôi dung.\n"
                "‚Ä¢ .nhay: B·∫Øt ƒë·∫ßu spam n·ªôi dung t·ª´ file content.txt.\n"
                "‚Ä¢ .stop: D·ª´ng spam.\n"
                "‚Ä¢ .del: X√≥a c√°c tin nh·∫Øn ch·ª©a link.\n"
                "‚Ä¢ All: Tag ·∫©n k√®m n·ªôi dung.\n"
                "‚Ä¢ .on : X√≥a t·∫•t c·∫£ tin nh·∫Øn sau khi l·ªánh ƒë∆∞·ª£c s·ª≠ d·ª•ng.\n"
                "‚Ä¢ .off: T·∫Øt ch·∫ø ƒë·ªô x√≥a tin nh·∫Øn.\n"
                "‚Ä¢ .admin <user_id>: Th√™m ng∆∞·ªùi d√πng v√†o admin.\n"
                "‚Ä¢ .list: Xem danh s√°ch admin.\n"
                "‚Ä¢ .info: Xem ID c·ªßa ng∆∞·ªùi d√πng.\n"
                "‚Ä¢ .kick @user: ƒêu·ªïi ng∆∞·ªùi d√πng kh·ªèi nh√≥m.\n"
                "‚Ä¢ .ask: Trao ƒë·ªïi tin nh·∫Øn v·ªõi bot.\n"
                "‚Ä¢ .uptime: Xem th·ªùi gian kh·ªüi t·∫°o bot.\n"
                "‚Ä¢ .anh: T·∫£i ·∫£nh g√°i.\n"
                "‚Ä¢ .anime: T·∫£i ·∫£nh anime.\n"
                "‚Ä¢ mute hoƒÉc mu: Mute m·ªôt th√†nh vi√™n.\n"
                "‚Ä¢ un: G·ª° mute.\n"
                "‚Ä¢ .du: Xem ·∫£nh du.\n"
                "‚Ä¢ .sexy: Xem ·∫£nh sexy.\n"
                
                "‚Ä¢ checkon:b·∫≠t ch·∫ø ƒë·ªô c·∫•m t·ª•c.\n"
                "‚Ä¢ checkoff: t·∫Øt ch·∫ø ƒë·ªô c·∫•m t·ª•c.\n"
                " ‚Ä¢ .random + s·ªë l∆∞·ª£ng: random acc golike(newly updated ).\n"
                " ‚Ä¢ .lq + s·ªë l∆∞·ª£ng(1>=10): random acc li√™n qu√¢n(newly updated ).\n"
                " ‚Ä¢ .id + idtiktok: xem th√¥ng tin nick (newly updated ).\n"
                " ‚Ä¢ .reo + @metion:spam metion (newly updated ).\n"
                " ‚Ä¢ .vip sdt : spamvip .\n"
                "‚Ä¢ .reo @metion tag metion li√™n t·ª•c.\n"
                "‚Ä¢ .stopreo ng·ª´ng spam ng∆∞·ªùi ƒë√≥ ch·ªânh delay ƒë·ªÉ nh·∫≠n l·ªánh nhanh h∆°n.\n"
                "‚Ä¢ .cannang @metion xem c√¢n n·∫∑ng ng∆∞·ªùi ƒë√≥\n"
                "‚Ä¢ .gay @metion xem ƒë·ªô gay ng∆∞·ªùi ƒë√≥.\n"
                "‚Ä¢ .ghepdoi @metion 1 v√† @metion:xem ƒë·ªô ph·ª• h·ª£p>\n"
                " ‚Ä¢ .dltt linkvstiktok\n"
                "‚Ä¢ .tb tag all v·ªõi th√¥ng b√°o.\n"
                "‚Ä¢ .rs n·ªôi dung tag ch√≠nh b·∫£n th√¢n m√¨nh.\n"
                "‚Ä¢ game ch∆°i game.,\n"
                "‚Ä¢ .dt ƒë·ªïi t√™n nh√≥m.\n"
                "‚Ä¢ .share tren bot.\n"
                "‚Ä¢ .shop xem shop .\n"
                "‚Ä¢ .nhapkey  nh·∫≠p key vip.\n"
                
                
            )            
            style_menu = MultiMsgStyle([
                MessageStyle(offset=0, length=15, style="font", size="14", auto_format=False),
                MessageStyle(offset=16, length=len(menu_text) - 16, style="font", size="12", auto_format=False),
                MessageStyle(offset=0, length=len(menu_text), style="color", color="#4caf50", auto_format=False),
            ])          
            self.replyMessage(
                Message(
                    text=menu_text,
                    style=style_menu
                ),
                message_object,
                thread_id=thread_id,
                thread_type=thread_type
            )
        
        elif message.startswith(".id"):
            parts = message.split(maxsplit=1)  
            if len(parts) == 2:
                tiktok_username = parts[1].strip()  
                api_url = f"https://apiquockhanh.click/tiktok?info={tiktok_username}"

                try:
                    response = requests.get(api_url)
                    if response.status_code == 200:
                        data = response.json()

                        if 'data' in data and 'user' in data['data']:
                            
                            user_info = (
                                f"Th√¥ng tin TikTok:\n"
                                f"- Nickname: {data['data']['user']['nickname']}\n"
                                f"- Followers: {data['data']['stats']['followerCount']}\n"
                                f"- Following: {data['data']['stats']['followingCount']}\n"
                                f"- Videos: {data['data']['stats']['videoCount']}\n"
                                f"- Heart Count: {data['data']['stats']['heartCount']}\n"
                                f"- Signature: {data['data']['user']['signature']}"
                            )
                            self.replyMessage(
                                Message(text=user_info),
                                message_object,
                                thread_id=thread_id,
                                thread_type=thread_type
                            )
                        else:
                            self.replyMessage(
                                Message(text="Kh√¥ng t√¨m th·∫•y th√¥ng tin cho ng∆∞·ªùi d√πng TikTok n√†y."),
                                message_object,
                                thread_id=thread_id,
                                thread_type=thread_type
                            )
                    else:
                        self.replyMessage(
                            Message(text="L·ªói khi truy c·∫≠p API TikTok."),
                            message_object,
                            thread_id=thread_id,
                            thread_type=thread_type
                        )
                except Exception as e:
                    self.replyMessage(
                        Message(text="ƒê√£ x·∫£y ra l·ªói khi l·∫•y th√¥ng tin TikTok."),
                        message_object,
                        thread_id=thread_id,
                        thread_type=thread_type
                    )
                    print(f"L·ªói khi x·ª≠ l√Ω l·ªánh .id: {e}")
            else:
                
                self.replyMessage(
                    Message(text="Sai c√∫ ph√°p! Vui l√≤ng s·ª≠ d·ª•ng: .id <tiktok_username>"),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
        
        if message.startswith(".admin"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            parts = message.split(' ', 1)
            if len(parts) < 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng cung c·∫•p user_id ƒë·ªÉ th√™m l√†m admin.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            new_admin_id = parts[1]
            idadmin.add(new_admin_id)
            self.save_admins(idadmin)
            self.replyMessage(Message(text=f'ƒê√£ th√™m {new_admin_id} v√†o danh s√°ch admin.'), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".list"):
            admin_list = "\n".join(idadmin)
            self.replyMessage(Message(text=f'Danh s√°ch admin:\n{admin_list}'), message_object, thread_id=thread_id, thread_type=thread_type)

        
        if message.startswith(".del"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            self.delete_links = not self.delete_links
            status = "B·∫≠t" if self.delete_links else "T·∫Øt"
            self.replyMessage(Message(text=f'‚úÖ ƒê√£ {status} ch·∫ø ƒë·ªô x√≥a li√™n k·∫øt.'), message_object, thread_id=thread_id, thread_type=thread_type)

        

        if message.startswith(".spam"):
            if author_id not in idadmin:
                self.replyMessage(Message(text=' B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            if self.spamming:
                self.replyMessage(Message(text='üö´ Spam ƒëang ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            parts = message.split(' ', 1)
            if len(parts) < 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng cung c·∫•p n·ªôi dung ƒëi ch·ª© Admin'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            spam_content = parts[1]
            self.spamming = True
            self.spam_thread = threading.Thread(target=self.spam_message, args=(spam_content, thread_id, thread_type))
            self.spam_thread.start()

        if message.startswith(".nhay"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            if self.spamming:
                self.replyMessage(Message(text='üö´ Spam ƒëang ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            try:
                with open('content.txt', 'r', encoding='utf-8') as file:
                    spam_content = file.read()
            except FileNotFoundError:
                self.replyMessage(Message(text='üö´ Kh√¥ng t√¨m th·∫•y file content.txt.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            self.spamming = True
            self.spam_thread = threading.Thread(target=self.spam_message, args=(spam_content, thread_id, thread_type))
            self.spam_thread.start()

        if message.startswith(".stop"):
            if not self.spamming:
                self.replyMessage(Message(text='üö´ Kh√¥ng c√≥ spam n√†o ƒëang ch·∫°y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            self.spamming = False
            if self.spam_thread is not None:
                self.spam_thread.join()
            self.replyMessage(Message(text='‚úÖ ƒê√£ d·ª´ng spam.'), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".on"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            self.xoatn_mode = True
            self.replyMessage(Message(text='Im l·∫∑ng l√† v√†ng c√°c e ƒë√£ b·ªã c·∫•m chat!ü§´.'), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".off"):
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            self.xoatn_mode = False
            self.messages_to_delete.clear()
            self.replyMessage(Message(text='ƒê√£ t·∫Øt ch·∫ø ƒë·ªô x√≥a tin nh·∫Øn.'), message_object, thread_id=thread_id, thread_type=thread_type)

        if message.startswith(".kick"):
            self.handle_kick(message_object, thread_id, author_id, thread_type)
            
        elif message.startswith("mute") or message.startswith("mu") or message.startswith(" ") or "mute" in message.lower():
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s√†i l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            mutenguoidung = self.load_mutenguoidung()
            if message_object.mentions and len(message_object.mentions) > 0:
                user_id = message_object.mentions[0]['uid']
                mention = Mention(user_id, length=8, offset=12)
                self.replyMessage(
                    Message(
                        text="N√≠n H·ªçng ƒêi @TagName", mention=mention
                    ),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
            else:
                user_id = author_id
                self.replyMessage(
                    Message(
                        text="B·∫°n ƒê√£ T·ª± H·ªßyüóø"
                    ),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
            if user_id not in mutenguoidung:
                mutenguoidung.add(user_id)
                self.save_mutenguoidung(mutenguoidung)
            self.isUndoLoop = True

        
        elif message.startswith("unmute") or "unmute" in message.lower():
            if author_id not in idadmin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s√†i l·ªánh n√†y.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            mutenguoidung = self.load_mutenguoidung()
            if message_object.mentions and len(message_object.mentions) > 0:
                user_id = message_object.mentions[0]['uid']
                mention = Mention(user_id, length=8, offset=12)
                self.replyMessage(
                    Message(
                        text="ƒê√£ h·ªßy c√¢m l·∫∑ng cho @TagName", mention=mention
                    ),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
            else:
                user_id = author_id
                self.replyMessage(
                    Message(
                        text="B·∫°n ƒë√£ t·ª± m·ªü kh√≥a c√¢m l·∫∑ng"
                    ),
                    message_object,
                    thread_id=thread_id,
                    thread_type=thread_type
                )
            if user_id in mutenguoidung:
                mutenguoidung.remove(user_id)
                self.save_mutenguoidung(mutenguoidung)
            self.isUndoLoop = False
        
            
   
        
        if self.xoatn_mode:
            self.messages_to_delete.append(message_object)

        list_link = ["t.me/", "https://", "http://", "https://zalo.me/g/", "zalo.me/g/", "zalo.me", "https://t.me/", "chinhphu.vn", "edu.vn", "gov.vn", "edu.gov.vn", "youtube", "tiktok", "https://www.youtube.com/"]

        if self.delete_links and any(link in message for link in list_link):
            try:
                self.deleteGroupMsg(
                    msgId=message_object.msgId, 
                    clientMsgId=message_object.cliMsgId, 
                    ownerId=author_id, 
                    groupId=thread_id
                )
            except Exception as e:
                print(f'Error deleting message: {e}')
        
        if self.xoatn_mode and self.messages_to_delete:
            for msg_obj in self.messages_to_delete:
                try:
                    self.deleteGroupMsg(
                        msgId=msg_obj.msgId, 
                        clientMsgId=msg_obj.cliMsgId, 
                        ownerId=author_id, 
                        groupId=thread_id
                    )
                except Exception as e:
                    print(f'Error deleting message: {e}')
            self.messages_to_delete.clear()
        if message.startswith(".tx"):
            menu_text = (
                "·¥Ö·¥Ä…¥ ú Íú±·¥ÄÃÅ·¥Ñ ú  ü·¥áÃ£ÃÇ…¥ ú:\n"
                        "‚Ä¢ .·¥Ö·¥Ä…¥…¢·¥ã è …¥·¥Ä·¥ç·¥á: ƒêƒÉng k√Ω v·ªõi t√™n v√† nh·∫≠n 500 tri·ªáu.\n"
                        "‚Ä¢ .…¢·¥Ä·¥ç·¥á ·¥õ/x/·¥Ñ/ ü s·ªë ti·ªÅn: Tham gia game.\n"
                        "‚Ä¢ .·¥Ñ·¥õ t√™n s·ªë ti·ªÅn: Chuy·ªÉn ti·ªÅn cho ng∆∞·ªùi kh√°c.\n"
                        "‚Ä¢ .code m√£ s·ªë ti·ªÅn: Nh·∫≠p m√£ code.\n"
                        "‚Ä¢ .Íú±·¥è·¥Ö·¥ú: Xem s·ªë d∆∞.\n"
                        "‚Ä¢ .·¥Ä·¥Ö·¥ç…™…¥ key: Tr·ªü th√†nh admin.\n"
                        "‚Ä¢ . ô·¥úÍú∞Íú∞ t√™n: Buff v√¥ h·∫°n ti·ªÅn cho ng∆∞·ªùi kh√°c (admin).\n"
                        "‚Ä¢ .…¥·¥è…¥·¥á …¥·¥Ä·¥ç·¥á Íú±·¥èÃÇÃÅ ·¥õ…™·¥áÃÇÃÄ…¥: ô·¥úÍú∞Íú∞ ·¥õ…™·¥áÃÇÃÄ…¥ …¥·¥è·¥è ô.\n"
            )            
            style_menu = MultiMsgStyle([
                MessageStyle(offset=0, length=15, style="font", size="14", auto_format=False),
                MessageStyle(offset=16, length=len(menu_text) - 16, style="font", size="12", auto_format=False),
                MessageStyle(offset=0, length=len(menu_text), style="color", color="#4caf50", auto_format=False),
            ])          
            self.replyMessage(
                Message(
                    text=menu_text,
                    style=style_menu
                ),
                message_object,
                thread_id=thread_id,
                thread_type=thread_type
            )
        
        elif message.startswith(".dangki"):
            user_name = message[len(".dangki "):].strip()
            if not user_name:
                self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn cung c·∫•p t√™n ƒë·ªÉ ƒëƒÉng k√Ω.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            registered_users = self.load_registered_users()

            if author_id in registered_users:
                self.replyMessage(Message(text='üö´ B·∫°n ƒë√£ ƒëƒÉng k√Ω r·ªìi!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            self.save_registered_user(author_id, user_name)
            self.replyMessage(Message(text=f'‚úÖ ƒêƒÉng k√Ω th√†nh c√¥ng! B·∫°n ƒë√£ ƒë∆∞·ª£c t·∫∑ng 500 tri·ªáu!'), message_object, thread_id=thread_id, thread_type=thread_type)

        elif message.startswith(".code"):
            args = message.split()
            if len(args) != 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: .code <m√£>'), message_object, thread_id, thread_type)
                return
            
            code = args[1].upper()
            if code in self.codes:
                registered_users = self.load_registered_users()
            
                if author_id not in registered_users:
                    self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn ƒëƒÉng k√Ω tr∆∞·ªõc khi nh·∫≠p m√£.'), message_object, thread_id, thread_type)
                    return
                
                
                user_name, balance = registered_users[author_id]
                amount = self.codes[code] 
                new_balance = balance + amount
                
                
                self.update_user_balance(author_id, new_balance)
                
                
                self.replyMessage(Message(text=f'‚úÖ B·∫°n ƒë√£ nh·∫≠p m√£ {code} th√†nh c√¥ng v√† nh·∫≠n ƒë∆∞·ª£c {amount}! S·ªë d∆∞ m·ªõi c·ªßa b·∫°n: {new_balance}'), message_object, thread_id, thread_type)
            else:
               
                self.replyMessage(Message(text='üö´ M√£ kh√¥ng h·ª£p l·ªá!'), message_object, thread_id, thread_type)

        elif message.startswith(".game"):
            registered_users = self.load_registered_users()
            if author_id not in registered_users:
                self.replyMessage(Message(text='üö´ B·∫°n c·∫ßn ƒëƒÉng k√Ω tr∆∞·ªõc khi ch∆°i game.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            args = message.split()
            if len(args) != 3:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: .game <T/X/C/L> <s·ªë ti·ªÅn>'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            bet_type = args[1].upper()
            try:
                bet_amount = int(args[2])
            except ValueError:
                self.replyMessage(Message(text='üö´ S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            if bet_amount <= 0:
                self.replyMessage(Message(text='üö´ S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            users_balance = registered_users[author_id][1]
            if users_balance < bet_amount:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ c∆∞·ª£c!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            dice_results = [random.randint(1, 6) for _ in range(3)]
            total = sum(dice_results)
            is_even = total % 2 == 0
            win_condition = (bet_type == 'T' and total > 10) or (bet_type == 'X' and total < 11) or \
                            (bet_type == 'C' and is_even) or (bet_type == 'L' and not is_even)

            if win_condition:
                result_text = "ch·∫µn" if is_even else "l·∫ª"
                self.replyMessage(Message(text=f'üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ th·∫Øng! K·∫øt qu·∫£: {dice_results} = {total} ({result_text}). B·∫°n nh·∫≠n ƒë∆∞·ª£c {bet_amount} ti·ªÅn!'), message_object, thread_id=thread_id, thread_type=thread_type)
                new_balance = users_balance + bet_amount
            else:
                result_text = "ch·∫µn" if is_even else "l·∫ª"
                self.replyMessage(Message(text=f'üò¢ B·∫°n ƒë√£ thua! K·∫øt qu·∫£: {dice_results} = {total} ({result_text}). B·∫°n m·∫•t {bet_amount} ti·ªÅn!'), message_object, thread_id=thread_id, thread_type=thread_type)
                new_balance = users_balance - bet_amount

            self.update_user_balance(author_id, new_balance)

        elif message.startswith(".sodu"):
            registered_users = self.load_registered_users()
            if author_id not in registered_users:
                self.replyMessage(Message(text='üö´ B·∫°n ch∆∞a ƒëƒÉng k√Ω!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            user_name, balance = registered_users[author_id]
            self.replyMessage(Message(text=f'üí∞ S·ªë d∆∞ c·ªßa b·∫°n l√†: {balance}'), message_object, thread_id=thread_id, thread_type=thread_type)

        elif message.startswith(".ct"):
            registered_users = self.load_registered_users()
            if author_id not in registered_users:
                self.replyMessage(Message(text='üö´ B·∫°n ch∆∞a ƒëƒÉng k√Ω!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            args = message.split()
            if len(args) != 3:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: .ct <t√™n> <s·ªë ti·ªÅn>'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            receiver_name = args[1]
            try:
                transfer_amount = int(args[2])
            except ValueError:
                self.replyMessage(Message(text='üö´ S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            if transfer_amount <= 0:
                self.replyMessage(Message(text='üö´ S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            sender_name, sender_balance = registered_users[author_id]
            if sender_balance < transfer_amount:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ chuy·ªÉn!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            recipient_id = next((uid for uid, (name, _) in registered_users.items() if name == receiver_name), None)
            if not recipient_id:
                self.replyMessage(Message(text='üö´ Ng∆∞·ªùi nh·∫≠n kh√¥ng t·ªìn t·∫°i!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            recipient_name, recipient_balance = registered_users[recipient_id]
            new_sender_balance = sender_balance - transfer_amount
            new_recipient_balance = recipient_balance + transfer_amount

            self.update_user_balance(author_id, new_sender_balance)
            self.update_user_balance(recipient_id, new_recipient_balance)
            self.replyMessage(Message(text=f'‚úÖ Chuy·ªÉn ti·ªÅn th√†nh c√¥ng! B·∫°n ƒë√£ chuy·ªÉn {transfer_amount} cho {recipient_name}. S·ªë d∆∞ m·ªõi c·ªßa b·∫°n: {new_sender_balance}'), message_object, thread_id=thread_id, thread_type=thread_type)

        elif message.startswith("key"):
            key = message[len(".key "):].strip()
            if key == self.admin_key:
                self.is_admin = True
                self.replyMessage(Message(text='üîê B·∫°n ƒë√£ tr·ªü th√†nh admin!'), message_object, thread_id=thread_id, thread_type=thread_type)
            else:
                self.replyMessage(Message(text='üö´ Sai m·∫≠t kh·∫©u admin!'), message_object, thread_id=thread_id, thread_type=thread_type)

        elif message.startswith(".neno"):
            
            
            args = message.split()
            if len(args) != 3:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: .none <t√™n> <s·ªë ti·ªÅn>'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            receiver_name = args[1]
            try:
                buff_amount = int(args[2])
            except ValueError:
                self.replyMessage(Message(text='üö´ S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            if buff_amount <= 0:
                self.replyMessage(Message(text='üö´ S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            registered_users = self.load_registered_users()
            recipient_id = next((uid for uid, (name, _) in registered_users.items() if name == receiver_name), None)
            if not recipient_id:
                self.replyMessage(Message(text='üö´ Ng∆∞·ªùi nh·∫≠n kh√¥ng t·ªìn t·∫°i!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            if recipient_id == author_id:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng th·ªÉ buff ti·ªÅn cho ch√≠nh m√¨nh!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            recipient_name, recipient_balance = registered_users[recipient_id]
            new_recipient_balance = recipient_balance + buff_amount
            self.update_user_balance(recipient_id, new_recipient_balance)
            self.replyMessage(Message(text=f'‚úÖ Buff ti·ªÅn th√†nh c√¥ng! B·∫°n ƒë√£ buff {buff_amount} cho {recipient_name}. S·ªë d∆∞ m·ªõi c·ªßa {recipient_name}: {new_recipient_balance}'), message_object, thread_id=thread_id, thread_type=thread_type)


        elif message.startswith(".buff"):
            if not self.is_admin:
                self.replyMessage(Message(text='üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            args = message.split()
            if len(args) != 2:
                self.replyMessage(Message(text='üö´ Vui l√≤ng nh·∫≠p ƒë√∫ng c√∫ ph√°p: .buff <t√™n>'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            user_name = args[1].strip()
            registered_users = self.load_registered_users()

            recipient_id = None
            for uid, (name, balance) in registered_users.items():
                if name.lower() == user_name.lower():
                    recipient_id = uid
                    break

            if recipient_id is None:
                self.replyMessage(Message(text=f'üö´ Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng t√™n {user_name}.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return

            self.update_user_balance(recipient_id, float('inf'))
            self.replyMessage(Message(text=f'‚úÖ ƒê√£ buff ti·ªÅn v√¥ h·∫°n cho ng∆∞·ªùi d√πng {user_name}!'), message_object, thread_id=thread_id, thread_type=thread_type)
    def send_private_message_to_user(self, user_id, random_data):
        """G·ª≠i n·ªôi dung sau khi random t·ª´ file ri√™ng t∆∞ ƒë·∫øn ng∆∞·ªùi d√πng."""
        try:
            message_text = f"th√¥ng tin nick:\n{random_data}"
            private_message = Message(text=message_text)
            self.send(private_message, thread_id=user_id, thread_type=ThreadType.USER)  
        except Exception as e:
            print(f"üö´ L·ªói khi g·ª≠i tin nh·∫Øn: {e}")
    
    def get_random_data(self, quantity):
        """L·∫•y ng·∫´u nhi√™n m·ªôt s·ªë l∆∞·ª£ng d√≤ng t·ª´ file gl.txt."""
        try:
            with open("gl.txt", "r", encoding="utf-8") as file:
                lines = file.readlines()
                if len(lines) < quantity:
                    return None  
                
                random_lines = random.sample(lines, quantity)
                return ''.join(random_lines)
        except FileNotFoundError:
            print("üö´ File gl.txt kh√¥ng t·ªìn t·∫°i.")
            return None
        except Exception as e:
            print(f"üö´ L·ªói khi ƒë·ªçc file: {e}")
            return None
    
    def log_message(self, author_id, thread_id, message_object):
        current_time = time.time()

        
        if author_id in self.message_log:
            self.message_log[author_id].append(current_time)
        else:
            self.message_log[author_id] = [current_time]

        
        self.message_log[author_id] = [t for t in self.message_log[author_id] if current_time - t < 10]

       
        if len(self.message_log[author_id]) >= self.spam_threshold:
            self.handle_spammer(author_id, thread_id, message_object)

    def handle_spammer(self, author_id, thread_id, message_object):
        if author_id not in self.excluded_user_ids:
            try:
                
                self.kickUsersFromGroup([author_id], thread_id)
                self.replyMessage(Message(text=f"üö´ Ng∆∞·ªùi d√πng {author_id} ƒë√£ b·ªã kick v√¨ spam!"), message_object, thread_id=thread_id, thread_type=thread_type)
            except Exception as e:
                print(f"Error kicking user: {e}")
        else:
            self.replyMessage(Message(text="üö´ Ng∆∞·ªùi d√πng n√†y n·∫±m trong danh s√°ch mi·ªÖn tr·ª´!"), message_object, thread_id=thread_id, thread_type=thread_type)
            
    def reo_spam_message(self, mentioned_user_id, thread_id, thread_type):
        """Spam mentions of a specific user."""
        while self.reo_spamming:
            mention = Mention(uid=mentioned_user_id, offset=0, length=5)
            spam_message = Message(text="@user", mention=mention)  
            self.send(spam_message, thread_id=thread_id, thread_type=thread_type)
            time.sleep(1)
     
    def handle_kick(self, message_object, thread_id, author_id, thread_type):
        
        idadmin = self.load_admins()
        if author_id not in idadmin:
            self.replyMessage(Message(text="üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y."), message_object, thread_id=thread_id, thread_type=thread_type)
            return

        mentions = getattr(message_object, 'mentions', None)
        if mentions:
            mentioned_user_id = mentions[0]['uid']
            if mentioned_user_id not in self.excluded_user_ids:
                try:
                    self.kickUsersFromGroup([mentioned_user_id], thread_id)
                    self.replyMessage(Message(text="thanh ni√™n n√†y qua xam lon n√™n b·ªã kick."), message_object, thread_id=thread_id, thread_type=thread_type)
                except ZaloAPIException:
                    self.replyMessage(Message(text="üö´ Kh√¥ng th·ªÉ ƒëu·ªïi ng∆∞·ªùi d√πng."), message_object, thread_id=thread_id, thread_type=thread_type)
            else:
                self.replyMessage(Message(text="üö´ Kh√¥ng th·ªÉ ƒëu·ªïi ng∆∞·ªùi d√πng n√†y."), message_object, thread_id=thread_id, thread_type=thread_type)
        else:
            self.replyMessage(Message(text="Nh·∫≠p t√™n th·∫±ng gay mu·ªën kick."), message_object, thread_id=thread_id, thread_type=thread_type)
    
    def ask_api(self, user_message):
        headers = {
            'Content-Type': 'application/json',
        }
        params = {
            'key': 'AIzaSyBDlktMVCY-M4gvxyw3f1yoQMa1mshgis0',  
        }
        json_data = {
            'contents': [
                {
                    'parts': [
                        {
                            'text': user_message,
                        },
                    ],
                },
            ],
        }

        try:
            response = requests.post(
                'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent',
                params=params,
                headers=headers,
                json=json_data,
            )
            response.raise_for_status()
            result = response.json()
            print("Ph·∫£n h·ªìi API:", result) 
            
            if 'candidates' in result and len(result['candidates']) > 0:
                candidate = result['candidates'][0]
                content = candidate.get('content', {})
                parts = content.get('parts', [])
                if parts and 'text' in parts[0]:
                    return parts[0]['text']
                else:
                    return 'Kh√¥ng c√≥ ph·∫ßn n·ªôi dung trong ph·∫£n h·ªìi.'
            else:
                return 'Kh√¥ng c√≥ ·ª©ng vi√™n n√†o trong ph·∫£n h·ªìi.'
        except requests.exceptions.RequestException as e:
            return f'L·ªói y√™u c·∫ßu API: {e}'
        except Exception as e:
            return f'ƒê√£ x·∫£y ra l·ªói: {e}'

    def spam_message(self, spam_content, thread_id, thread_type):
        words = spam_content.split()
        while self.spamming:
            for word in words:
                if not self.spamming:
                    break
                mention = Mention(uid='-1', offset=0, length=len(word))
                spam_message = Message(text=word, mention=mention)
                self.send(spam_message, thread_id=thread_id, thread_type=thread_type)
                time.sleep(1)
    def remove_banned_words(self, message):
        cleaned_message = message
        for word in self.banned_words: 
            cleaned_message = cleaned_message.replace (word, "[censored]")
        return cleaned_message
    def add_to_spam_list(self, phone_number):
       
        url = f"https://thanhphucdev.net/api/thanhphuc.php?sdt={phone_number}"
        try:
            response = requests.get(url)
            if response.status_code == 200:
                return f"‚úÖ Added phone number {phone_number} to the spam list."
            else:
                return "üö´ Could not add phone number to the spam list."
        except requests.exceptions.RequestException as e:
            return f"üö´ Error: {str(e)}"
    def download_tiktok_video(self, video_url, message_object, thread_id, thread_type):
        """Download TikTok video and send details back to user."""
        api_url = f"https://apiquockhanh.click/tiktok?video={video_url}"
        
        try:
            response = requests.get(api_url)
            response.raise_for_status()
            data = response.json()

            if data.get("code") != 0:
                self.replyMessage(Message(text='üö´ Kh√¥ng th·ªÉ t·∫£i video. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë∆∞·ªùng d·∫´n.'), message_object, thread_id=thread_id, thread_type=thread_type)
                return
            
            video_data = data.get("data", {})
            title = video_data.get("title", "Kh√¥ng c√≥ ti√™u ƒë·ªÅ")
            duration = video_data.get("duration", 0)
            play_url = video_data.get("play", "")
            cover_url = video_data.get("cover", "")
            music_info = video_data.get("music_info", {})
            music_title = music_info.get("title", "Kh√¥ng c√≥ t√™n nh·∫°c")
            music_author = music_info.get("author", "Kh√¥ng c√≥ t√°c gi·∫£")
            download_url = play_url  

            message = (
                f"**Ti√™u ƒë·ªÅ:** {title}\n"
                f"**Th·ªùi gian:** {duration} gi√¢y\n"
                f"**Link video:** {play_url}\n"
                f"**ƒê∆∞·ªùng d·∫´n t·∫£i video:** [T·∫£i t·∫°i ƒë√¢y]({download_url})\n"  
                f"**H√¨nh ·∫£nh b√¨a:** {cover_url}\n"
                f"**T√™n nh·∫°c:** {music_title}\n"
                f"**T√°c gi·∫£ nh·∫°c:** {music_author}"
            )
            self.replyMessage(Message(text=message), message_object, thread_id=thread_id, thread_type=thread_type)
        
        except requests.RequestException as e:
            print(f"Error fetching video: {e}")
            self.replyMessage(Message(text="üö´ C√≥ l·ªói khi l·∫•y video."), message_object, thread_id=thread_id, thread_type=thread_type)
    
    

    def add_to_spam_list(self, phone_number):
        """Add a phone number to the spam list via API call."""
        url = f"https://thanhphucdev.net/api/thanhphuc.php?sdt={phone_number}"
        try:
            response = requests.get(url)
            if response.status_code == 200:
                return f"‚úÖ Added phone number {phone_number} to the spam list."
            else:
                return "üö´ Could not add phone number to the spam list."
        except requests.exceptions.RequestException as e:
            return f"üö´ Error: {str(e)}"
    def reo_spam_message(self, mentioned_user_id, thread_id, thread_type):
        """Spam mentions of a specific user."""
        while self.reo_spamming:
            mention = Mention(uid=mentioned_user_id, offset=0, length=5)
            spam_message = Message(text="@user", mention=mention)  
            self.send(spam_message, thread_id=thread_id, thread_type=thread_type)
            time.sleep(0)  
    
    def changeGroupName(self, groupName, groupId):
        params = {
            "zpw_ver": 641,
            "zpw_type": 30
        }
        
        payload = {
            "params": self._encode({
                "gname": groupName,  
                "grid": str(groupId)
            })
        }
        
        response = self._post("https://tt-group-wpa.chat.zalo.me/api/group/updateinfo", params=params, data=payload)
        data = response.json()
        results = data.get("data") if data.get("error_code") == 0 else None
        if results:
            results = self._decode(results)
            results = results.get("data") if results.get("data") else results
            if results is None:
                results = {"error_code": 1337, "error_message": "Data is None"}
            
            if isinstance(results, str):
                try:
                    results = json.loads(results)
                except:
                    results = {"error_code": 1337, "error_message": results}
            
            return Group.fromDict(results, None)
        return None
    
	    
	    
    
    

def save_group_ids(group_ids):
    with open('group.json', 'w') as group_file:
        json.dump({"group_ids": group_ids}, group_file, indent=4)

def load_mutenguoidung():
    try:
        with open('mute.json', 'r') as mute_file:
            data = json.load(mute_file)
            if isinstance(data, dict):
                return set(data.get('mutenguoidung', []))
            elif isinstance(data, list):
                return set(data)
            else:
                return set()
    except (FileNotFoundError, json.JSONDecodeError):
        return set()

def save_mutenguoidung(mutenguoidung):
    with open('mute.json', 'w') as mute_file:
        json.dump({'mutenguoidung': list(mutenguoidung)}, mute_file)




imei = "7c7bb9b2-08a1-446d-9a75-613d16d64d47-b78b4e2d6c0a362c418b145fe44ed73f"
session_cookies = ({"_ga":"GA1.2.1750407579.1730738316","_gid":"GA1.2.1584871262.1730738316","_ga_VM4ZJE1265":"GS1.2.1730738317.1.0.1730738317.0.0.0","_zlang":"vn","app.event.zalo.me":"7093867920015212027","_gat":"1","zpsid":"H4RE.425362398.1.HzhGWNrH81kZqde2SL4W6mWYKYzFP1CjJs8P8mpe3LjEltY6VAGjCXfH81i","zpw_sek":"nq0p.425362398.a0.HiX5BhLPw0zhsh8Mb5de3yvxZMINOye-WpRVNTO0gMM0AOPvnIk0JjGMXKBIPDKjo2XH8lLg1bSeM1y2d3xe3m"})

honhattruong = Honhattruong('api_key', 'secret_key', imei=imei, session_cookies=session_cookies)
honhattruong.listen()
